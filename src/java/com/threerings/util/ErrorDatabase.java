//
// $Id$

package com.threerings.util;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintWriter;

import java.util.Iterator;
import java.util.Map;
import java.util.regex.Pattern;

import com.google.common.collect.Maps;

/**
 * A helper used by {@link OOOFileAppender} to track recorded errors.
 */
public class ErrorDatabase
{
    /**
     * Reads the contents of the supplied file into this error database. The file must have been
     * generated by a previous call to {@link #writeTo}. If the file is null or does not exist,
     * this method leaves the database unchanged (empty).
     */
    public void readFrom (String database)
        throws IOException
    {
        File dbfile;
        if (database == null || !(dbfile = new File(database)).exists()) {
            return;
        }

        String line;
        BufferedReader reader = new BufferedReader(new FileReader(dbfile));
        while ((line = reader.readLine()) != null) {
            Error error = new Error();
            if (error.fromLine(line)) {
                _errors.put(error.message, error);
            }
        }
    }

    /**
     * Writes this error database to the supplied file. If the file is null, this method NOOPs.
     */
    public void writeTo (String database)
        throws IOException
    {
        if (database == null) {
            return;
        }

        PrintWriter out = new PrintWriter(new BufferedWriter(new FileWriter(database)));
        for (Error error : _errors.values()) {
            out.println(error.toLine());
        }
        out.close();
    }

    /**
     * Prunes errors that have not been seen in a week.
     */
    public void pruneOldErrors (long nowStamp)
    {
        long cutoff = nowStamp - 7 * DAY_MILLIS;
        for (Iterator<Error> iter = _errors.values().iterator(); iter.hasNext(); ) {
            Error error = iter.next();
            if (error.mostRecentStamp < cutoff) {
                iter.remove();
            }
        }
    }

    /**
     * Returns true if the supplied message should be displayed in summary form only (ie. has been
     * showing up in the logs for at least three days). The message will be noted in the database
     * as a result of this call: new messages will be added, old messages will be noted as seen.
     */
    public boolean shouldSummarize (long nowStamp, String message)
    {
        Error error = _errors.get(message);
        if (error == null) {
            _errors.put(message, error = new Error(nowStamp, message));
        }
        error.mostRecentStamp = nowStamp;
        return (nowStamp - error.firstStamp > 3 * DAY_MILLIS);
    }

    protected static class Error
    {
        public long firstStamp;
        public long mostRecentStamp;
        public String message;

        public Error () {
        }

        public Error (long now, String message) {
            this.firstStamp = now;
            this.mostRecentStamp = now;
            this.message = message;
        }

        public String toLine () {
            return this.firstStamp + " " + this.mostRecentStamp + " " + this.message;
        }

        public boolean fromLine (String line) {
            try {
                String[] bits = SPLITTER.split(line, 3);
                this.firstStamp = Long.parseLong(bits[0]);
                this.mostRecentStamp = Long.parseLong(bits[1]);
                this.message = bits[2];
                return true;
            } catch (Exception e) {
                return false;
            }
        }
    }

    protected Map<String,Error> _errors = Maps.newHashMap();

    protected static final Pattern SPLITTER = Pattern.compile(" ");
    protected static final long DAY_MILLIS = 24 * 60 * 60 * 1000L;
}
